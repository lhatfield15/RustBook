Chap 1.3: cargo check
Chap 2: 
    prelude
    readline appends, not replaces 
    if you pass a ref without mut its immutable
    Result type is enum, OK & Err
    crates.io
    default int is i32
    shadowing is easy
Chap 3.2
    interger overflow panics in --debug, 2's complement wraps in --release
Chap 3.5
    break counter * 2; //for breaking from a loop and returning the expression
    'counting_up: loop { } // label loop so you can later break out it from an inner loop with
    break 'counting_up;
Chap 4.2
    Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference
    if you have a mut ref, only one ref can exist
Chap 4.3
    String = string, str = slice
Chap 5.1
    to make a new struct with only a few diff fields. Be aware - if anything is moved, user1 is invalid
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };

    Tuple structs for naming clarity (Point vs Color)

5.3
    use impl for method on a struct
    automatic referencing and dereferencing
6.1
    enum with type:
        enum IpAddr {
            V4(String),
            V6(String),
        }
    with diff types
         enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    you can define methods on enums!
    billion dollar mistake - null refs
6.2
    match must cover all possibilites
6.3
    use if let instead of match if you really only care about one branch
        if let Coin::Quarter(state) = coin {
        println!("State quarter from {state:?}!");
    } else {
        count += 1;
    }
7.1
    A crate is the smallest amount of code that the Rust compiler considers at a time
    A crate can come in one of two forms: a binary crate or a library crate
    A package is a bundle of one or more crates that provides a set of functionality

7.3
    pub for structs -> all members private unless otherwise specified
    pub for enum -> all members public 
7.4
    use for a function -> specify parent module for clarity that what you're calling isn't local
    use fot struct/enum -> use whole path
    for conflicting names, specify parent or use as keyword
    pub use = re exporting
    for multiple imports from same crate
        use std::{cmp::Ordering, io};
